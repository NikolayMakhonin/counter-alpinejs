// from: https://www.freecodecamp.org/news/build-a-pwa-from-scratch-with-html-css-and-javascript/

var timestamp = 1609387811214
var cacheName = "cache".concat(timestamp);

// use: dir /s/b > list.txt
const assets = [
	"/assets",
	"/buttons.css",
	"/components.html",
	"/helpers.css",
	"/helpers.js",
	"/icons",
	"/index.html",
	"/layout.css",
	"/lib",
	"/list.txt",
	"/manifest.json",
	"/normalize.css",
	"/ReadMe.md",
	"/reset.css",
	"/service-worker.js",
	"/style.css",
	"/styles.js",
	"/assets/icons",
	"/assets/sounds",
	"/assets/icons/logo-192.png",
	"/assets/icons/logo-512.png",
	"/assets/sounds/click-1.mp3",
	"/assets/sounds/click-2.mp3",
	"/assets/sounds/click-3.mp3",
	"/assets/icons/menu.svg",
	"/assets/icons/numeric-0.svg",
	"/assets/icons/numeric-1.svg",
	"/assets/icons/play.svg",
	"/assets/icons/stop.svg",
	"/assets/icons/undo.svg",
	"/assets/icons/volume-high.svg",
	"/lib/NoSleep.min.js",
	"/service-worker-index.html"
]

self.addEventListener("install", installEvent => {
  installEvent.waitUntil(
    caches.open(cacheName).then(cache => {
      cache.addAll(assets)
    })
  )
})

self.addEventListener("fetch", fetchEvent => {
  fetchEvent.respondWith(
    caches.match(fetchEvent.request).then(res => {
      return res || fetch(fetchEvent.request)
    })
  )
})


// from: https://github.com/sveltejs/sapper-template/blob/rollup/src/service-worker.js

// region Config

// This file is generated by Sapper — do not edit it!

// use dir /s/b > list.txt

var files = [
	"/assets",
	"/buttons.css",
	"/components.html",
	"/helpers.css",
	"/helpers.js",
	"/icons",
	"/index.html",
	"/layout.css",
	"/lib",
	"/list.txt",
	"/manifest.json",
	"/normalize.css",
	"/ReadMe.md",
	"/reset.css",
	"/service-worker.js",
	"/style.css",
	"/styles.js",
	"/assets/icons",
	"/assets/sounds",
	"/assets/icons/logo-192.png",
	"/assets/icons/logo-512.png",
	"/assets/sounds/click-1.mp3",
	"/assets/sounds/click-2.mp3",
	"/assets/sounds/click-3.mp3",
	"/assets/icons/menu.svg",
	"/assets/icons/numeric-0.svg",
	"/assets/icons/numeric-1.svg",
	"/assets/icons/play.svg",
	"/assets/icons/stop.svg",
	"/assets/icons/undo.svg",
	"/assets/icons/volume-high.svg",
	"/lib/NoSleep.min.js",
	"/service-worker-index.html"
]

var shell = []

// var routes = [
	// { pattern: /^\/$/ },
	// { pattern: /^\/main\/?$/ },
	// { pattern: /^\/main\/tailwind\/?$/ },
	// { pattern: /^\/dev\/?$/ },
	// { pattern: /^\/dev\/components\/?$/ },
	// { pattern: /^\/dev\/components\/medium\/dropdowns\/?$/ },
	// { pattern: /^\/dev\/components\/medium\/inputs\/?$/ },
	// { pattern: /^\/dev\/components\/small\/font-families\/?$/ },
	// { pattern: /^\/dev\/components\/small\/buttons\/?$/ },
	// { pattern: /^\/dev\/components\/small\/markers\/?$/ },
	// { pattern: /^\/dev\/components\/small\/fonts\/?$/ },
	// { pattern: /^\/dev\/components\/small\/icons\/?$/ },
	// { pattern: /^\/dev\/app-info\/?$/ },
	// { pattern: /^\/dev\/validate\/?$/ },
	// { pattern: /^\/dev\/webrain\/?$/ },
	// { pattern: /^\/dev\/status\/?$/ },
	// { pattern: /^\/dev\/tests\/?$/ }
// ];

// endregion

var ASSETS = "cache".concat(timestamp); // `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory

var to_cache = shell.concat(files);
var staticAssets = new Set(to_cache);
self.addEventListener('install', function (event) {
  event.waitUntil(caches.open(ASSETS).then(function (cache) {
    return cache.addAll(to_cache);
  }).then(function () {
    self.skipWaiting();
  }));
});
self.addEventListener('activate', function (event) {
  event.waitUntil(caches.keys().then(function (keys) {
    var key;
    return Promise.resolve().then(function () {
      if (key !== ASSETS) {
        return caches.delete(key);
      }
    }).then(function () {
      // delete old caches
      for (key of keys) {}

      self.clients.claim();
    });
  }));
});
/**
 * Fetch the asset from the network and store it in the cache. 
 * Fall back to the cache if the user is offline.
 */

function fetchAndCache(request) {
  var cache, response, response;
  return Promise.resolve().then(function () {
    return caches.open("offline".concat(timestamp));
  }).then(function (_resp) {
    cache = _resp;
    return Promise.resolve().then(function () {
      return fetch(request);
    }).then(function (_resp) {
      response = _resp;
      cache.put(request, response.clone());
      return response;
    }).catch(function (err) {
      return Promise.resolve().then(function () {
        return cache.match(request);
      }).then(function (_resp) {
        response = _resp;

        if (response) {
          return response;
        }

        throw err;
      });
    });
  }).then(function () {});
}

self.addEventListener('fetch', function (event) {
  if (event.request.method !== 'GET' || event.request.headers.has('range')) return;
  var url = new URL(event.request.url); // don't try to handle e.g. data: URIs

  var isHttp = url.protocol.startsWith('http');
  var isDevServerRequest = url.hostname === self.location.hostname && url.port !== self.location.port;
  var isStaticAsset = url.host === self.location.host && staticAssets.has(url.pathname);
  var skipBecauseUncached = event.request.cache === 'only-if-cached' && !isStaticAsset;

  if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
    event.respondWith(function () {
      var cachedAsset;
      return Promise.resolve().then(function () {
        return isStaticAsset && caches.match(event.request);
      }).then(function (_resp) {
        // always serve static files and bundler-generated assets from cache.
        // if your application has other URLs with data that will never change,
        // set this variable to true for them and they will only be fetched once.
        cachedAsset = _resp; // for pages, you might want to serve a shell `service-worker-index.html` file,
        // which Sapper has generated for you. It's not right for every
        // app, but if it's right for yours then uncomment this section

        /*
        if (!cachedAsset && url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
        	return caches.match('/service-worker-index.html');
        }
        */

        return cachedAsset || fetchAndCache(event.request);
      });
    }());
  }
});